/* -*- coding: utf-8 -*- */
/* -----------------------------------------------------------------------------
 * Copyright (C) 2009-2010  Nicolas P. Rougier
 *
 * Distributed under the terms of the BSD License. The full license is in
 * the file COPYING, distributed as part of this software.
 * -----------------------------------------------------------------------------
 */
/*
 * Disaplecement vertex shader
 * ---------------------------
 */
//#version 130
//precision highp float;
//precision highp int;

uniform sampler2D texture;
uniform sampler1D kernel;
uniform vec2 pixel;
void main() {
    gl_TexCoord[0] = gl_MultiTexCoord0;  
    gl_FrontColor = gl_Color;
    vec4 vertex = gl_Vertex;
    gl_TexCoord[0].xy = gl_MultiTexCoord0.xy;
    vertex.z += texture2D_bicubic (texture, kernel, gl_MultiTexCoord0.xy, pixel).a;

    
    // float tl = abs(tex2D (displacementSampler, uv + texelSize * float2(-1, -1)).x);   // top left
    // float  l = abs(tex2D (displacementSampler, uv + texelSize * float2(-1,  0)).x);   // left
    // float bl = abs(tex2D (displacementSampler, uv + texelSize * float2(-1,  1)).x);   // bottom left
    // float  t = abs(tex2D (displacementSampler, uv + texelSize * float2( 0, -1)).x);   // top
    // float  b = abs(tex2D (displacementSampler, uv + texelSize * float2( 0,  1)).x);   // bottom
    // float tr = abs(tex2D (displacementSampler, uv + texelSize * float2( 1, -1)).x);   // top right
    // float  r = abs(tex2D (displacementSampler, uv + texelSize * float2( 1,  0)).x);   // right
    // float br = abs(tex2D (displacementSampler, uv + texelSize * float2( 1,  1)).x);   // bottom right
 
    // // Compute dx using Sobel:
    // //           -1 0 1 
    // //           -2 0 2
    // //           -1 0 1
    // float dX = tr + 2*r + br -tl - 2*l - bl;
 
    // // Compute dy using Sobel:
    // //           -1 -2 -1 
    // //            0  0  0
    // //            1  2  1
    // float dY = bl + 2*b + br -tl - 2*t - tr;
 
    // // Build the normalized normal
    // float4 N = float4(normalize(float3(dX, 1.0f / normalStrength, dY)), 1.0f);
 
    // //convert (-1.0 , 1.0) to (0.0 , 1.0), if needed
    // return N * 0.5f + 0.5f;

    gl_Position = gl_ModelViewProjectionMatrix*vertex;         
}
